<html>
<header>
</header>
<style type="text/css">
	div {
		font-size:30;
		vertical-align: center;
		color:white;
		font-family: sans-serif;
		height:50px;
		background-color:darkblue;
		margin-top:0px;
		width:10px;
	}

</style>
<script src="node_modules/webmidi/webmidi.min.js"></script>
<script type="text/javascript" src="node_modules/paper/dist/paper-full.js"></script>
<script type="text/paperscript" canvas="myCanvas">

	var pendingNotes = {};
	var timeline = [];
	var noteList = [];
	var timeOffset = 0;
	var lastNoteTime = 0;
	var timeState = "new";
	var keyMap = {};
	var ScaleSize = 12;

	var PlayingPixelsPerSecond = 0.1;
	var NoteSpacing = 20;
	var NoteWidth = 35;
	var FirstNote = {name:"C",octave:-1};
	var CutoffPos = 2000;
	var SilenceDelay = 500;
	var HarmonyTime = 200;
	
	var patternMatches = {};

	var PatternDefinitions = [
		// {name:'Major4',pattern:[4,3,5],color:{hue:40,saturation:1.0,brightness:1.0}},
		{name:'Major',pattern:[4,3],color:{hue:0,saturation:1.0,brightness:1.0}},
		// {name:'Minor4',pattern:[3,4,5],color:{hue:40,saturation:1.0,brightness:1.0}},
		{name:'Minor',pattern:[3,4],color:{hue:50,saturation:1.0,brightness:1.0}},
		{name:'dim7',pattern:[3,3,3],color:{hue:120,saturation:1.0,brightness:1.0}},
		{name:'Dim',pattern:[3,3],color:{hue:120,saturation:1.0,brightness:1.0}},
		{name:'Aug',pattern:[4,4],color:{hue:200,saturation:1.0,brightness:1.0}},
		{name:'Maj6',pattern:[9],color:{hue:120,saturation:1.0,brightness:1.0}}
	];	
	var patterns = [];


	function makePianoNote(sourceEvent){

		var e = {event:sourceEvent,note:sourceEvent.note,canDelete:false};

		e.rect = new Path.Rectangle(new Point(0,0), new Size(NoteWidth,200));
		e.rect.fillColor = 'blue';
		e.rect.fillColor.alpha = 0.05 + Math.max(0,((0.95/80.0) * Math.max(sourceEvent.rawVelocity-20,0)));
		e.rect.fillColor.saturation = 0.05 + Math.max(0,((0.95/80.0) * Math.max(sourceEvent.rawVelocity-20,0)));
		e.rect.fillColor.hue = sourceEvent.rawVelocity * (360.0/90.0);

		e.line = new Path.Line(new Point(0,0),new Point(2000,0));
		e.line.strokeColor = 'black';
		e.line.strokeColor.alpha = 0.1;

		

		e.getKey = function(){return this.note.name + this.note.octave};
		e.getTimeKey = function(){return this.note.name + this.note.octave + this.event.timestamp};

		var name = sourceEvent.note.name + " (" + sourceEvent.rawVelocity + ")";

		e.label = new PointText({
					content:name,
					justification: 'left',
					fontSize: 12
					// strokeColor:'black',
					// shadowColor:'white',
					// shadowOffset: new Point(0,0),
					// shadowBlur: 5
				});

		e.draw = function(drawTime){

			var rect = this.rect;
			var line = this.line;
			var endline = this.endline;

			var bottom = getDrawPos(drawTime,this.event.timestamp);

			var endTime = drawTime;
			if (this.endTime)
				endTime = this.endTime;

			var top = getDrawPos(drawTime,endTime);
			var height = top - bottom;
			
			rect.segments[0].point.y = bottom;
			rect.segments[3].point.y = bottom;

			rect.segments[1].point.y = top;
			rect.segments[2].point.y = top;

			rect.position.x = (notePosition(this.note) - notePosition(FirstNote)) * NoteSpacing;

			line.segments[0].point.y = bottom;
			line.segments[1].point.y = bottom;

			this.top = top;
			this.left = rect.position.x-(NoteWidth/2);
			this.right = rect.position.x+(NoteWidth/2);
			this.bottom = bottom;

			if (endline){
				endline.segments[0].point.y = top;
				endline.segments[1].point.y = top;
			}

			this.label.point = new Point(this.left,bottom - this.label.strokeBounds.height/2);

			if (bottom > CutoffPos){
				this.canDelete = true;
			}
		}

		e.delete = function(){
			this.rect.remove();
			this.line.remove();
		};

		e.endEvent = function(timestamp){

			//this.endline = new Path.Line(new Point(0,0),new Point(2000,0));
			//this.endline.strokeColor = 'black';
			//this.endline.strokeColor.alpha = 0.1;
			this.endTime = timestamp;
			this.duration = timestamp - this.event.timestamp;
		}

		e.getNoteNumber = function(){
			if (!this._noteNum) {
				this._noteNum = noteTone(this.note);				
			}
			return this._noteNum;
		}

		return e;		
	}

	function makePattern(pattern,inversion,patternDef)
	{
		var patternName = patternDef.name;
		var patternColor = new Color(patternDef.color);
		// patternColor.saturation = 1.0 / Math.max(1,inversion+1);	

		if (inversion != 0) {
			patternName = patternDef.name + " Inv" + inversion;
		}

		return {
			pattern : pattern,
			inversion : inversion,
			color : patternColor,
			name : patternDef.name,
			patternName : patternName,
			rootPosition : ((pattern.length+1) - inversion)%(pattern.length+1)
		};
	}

	function makePatternMatch(matchedNotes,patternDef){

		var patternMatch = {notes:matchedNotes,patternDef:patternDef,canDelete:false};

		patternMatch.draw = function(){

			if (!this.rect){

				this.rect = new Path.Rectangle(new Point(0,0), new Size(1,1));
				
				this.rect.fillColor = this.patternDef.color.clone();
				this.rect.fillColor.alpha = 0.05;

				this.rect.strokeColor = this.patternDef.color.clone();
				this.rect.strokeColor.alpha = 0.8;
				

				this.label = new PointText({
					content:this.getName(),
					justification: 'left',
					fontSize: 15
					// strokeColor:'black',
					// shadowColor:'white',
					// shadowOffset: new Point(0,0),
					// shadowBlur: 5
				});

				// this.label.fillColor.brightness = 0.2;
				// this.label.fillColor.alpha = 1.0;

			}

			var rect = this.rect;
			var bottom = 0, top = 10000, left = 10000, right = 0;

			for (var i=0;i<this.notes.length;i++){
				var note = this.notes[i];
				bottom = Math.max(bottom,note.bottom);
				top = Math.min(top,note.top);
				right = Math.max(right,note.right);
				left = Math.min(left,note.left);
				this.canDelete = note.canDelete && this.canDelete;
			}

			// this.label.point = new Point(left + (right-left)/2,top + (bottom-top)/2);
			this.label.point = new Point(left,bottom + this.label.strokeBounds.height);

			rect.segments[0].point = new Point(left,bottom);
			rect.segments[3].point = new Point(right,bottom);

			rect.segments[1].point = new Point(left,top);
			rect.segments[2].point = new Point(right,top);
		}

		patternMatch.delete = function(){
			if (this.rect)
				this.rect.remove();
			if (this.label)
				this.label.remove();
		};

		patternMatch.getName = function(){
			return this.notes[this.patternDef.rootPosition].note.name + "_" + this.patternDef.patternName;
		};

		patternMatch.getUniqueKey = function(){
			return this.notes[this.patternDef.rootPosition].getTimeKey() + "_" + this.patternDef.patternName;
		};

		return patternMatch;
	}


	function init()
	{
		timeline.push({start:(new Date()).getTime(),pixelsPerSecond:PlayingPixelsPerSecond});
		timeState = "running";
		lastNoteTime = (new Date()).getTime();

		patterns = [];
		for (var p = 0;p<PatternDefinitions.length;p++)
		{
			var patternDef = PatternDefinitions[p];
			var inversions = generateInversions(patternDef.pattern);
			for (var i = 0;i< inversions.length;i++)
			{
				patterns.push(makePattern(inversions[i],i,patternDef));
			}
		}
		console.log(JSON.stringify(patterns));
	}

	function getKey(event){
		return event.note.name + event.note.octave;
	}

	function notePosition(note){
		return noteTone(note);
		// var noteVal = (((note.name.charCodeAt(0) - "C".charCodeAt(0)) % 7) + 7) % 7;
		// if (note.name.length == 2) noteVal += 0.5;
		// return  (noteVal + note.octave * 7) + 18;
	}

	function noteOrderComparator(note1,note2)
	{
		if (note1 && note2)
			return note1.getNoteNumber() - note2.getNoteNumber();
		
		if (note1 && !note2)
			return 1;
		if (note2 && !note1)
			return -1;
		
		return 0;
	}
  
	var noteMap = {
		"C":0,
		"C#":1,
		"D":2,
		"D#":3,
		"E":4,
		"F":5,
		"F#":6,
		"G":7,
		"G#":8,
		"A":9,
		"A#":10,
		"B":11
	};

	function generateInversions(pattern){

		var inversions = [];
		inversions.push(pattern);

		if (pattern.length < 2) return inversions;

		for (var i = 0; i < pattern.length; i++){

			var lastInversion = inversions[inversions.length-1];
			var inversion = lastInversion.slice(1,lastInversion.length);

			var newInterval = ScaleSize - lastInversion.reduce(function(a,b){return a+b});
			if (newInterval != 0)
				inversion.push(newInterval);
			else 
				inversion.push(lastInversion[0]);

			if (JSON.stringify(inversion) != JSON.stringify(pattern))
				inversions.push(inversion);
		}
		return inversions;
	}

	function noteTone(note){
		if (noteMap[note.name] == null) throw {"oh":note.name};
		return noteMap[note.name] + (note.octave*12);
	}
	
	function matchPattern(intervals,pattern)
	{ 
		var match = [];
		for (var i=0, p = 0;p < pattern.length && i < intervals.length;i++){
			if (intervals[i] != pattern[p]){
				p = 0;
				match = [];
			} else {
				p++;
				match.push(i);
			}
		}
		if (match.length == pattern.length)
			return match;		
		return null;
	}

	function extractMatchedNotes(match,sortedCluster){
		var matchedNotes = [];
		for (var i=0;i<match.length+1;i++)
		{
			matchedNotes.push(sortedCluster[match[0]+i]);
		}
		console.log("Extracted: " + matchedNotes.length);
		return matchedNotes;
	}

	function extractValues(obj){
		var values = [];
		for (var key in obj){
			values.push(obj[key]);
		}
		return values;
	}

	function findPatterns(pianoNote) 
	{
		var cluster = extractValues(pianoNote.siblings);
		cluster.push(pianoNote);
		
		var sortedCluster = cluster.sort(noteOrderComparator);
		// console.log(JSON.stringify(sortedCluster));

		var intervals = [];
		for (var i=0;i<sortedCluster.length-1;i++)
		{ 
			intervals.push(sortedCluster[i+1].getNoteNumber() - sortedCluster[i].getNoteNumber());
		}

		for (var p=0;p<patterns.length;p++)
		{
			var patternDef = patterns[p];
			var match = matchPattern(intervals,patternDef.pattern);
			if (match)
			{
				var matchedNotes = extractMatchedNotes(match,sortedCluster);
				var patternMatch = makePatternMatch(matchedNotes,patternDef);

				if (!patternMatches[patternMatch.getUniqueKey()])
				{
					patternMatches[patternMatch.getUniqueKey()] = patternMatch;
					console.log("Match: " + patternMatch.getName());
				} else {
					console.log("Duplicate match " + patternMatch.getName());
					patternMatch.delete();
				}
				break;
			}
		}		
	}

	
	function joinPianoNote(pianoNote){

		function compareNote(note1,note2){
			if (note2.endTime){
				if (note1.event.timestamp - note2.endTime < HarmonyTime){
					return true;
				}
				return false;
			}
			return true;
		};

		pianoNote.siblings = {};

		for (var i=0;i<noteList.length;i++){

			var note = noteList[i];
			if (!note) continue;
			if (compareNote(pianoNote,note)){
				note.siblings[pianoNote.getTimeKey()] = pianoNote;
				pianoNote.siblings[note.getTimeKey()] = note;
			}
		}
	}

	function printTimestamp(timestamp){
		var date =  new Date(timestamp);
		return date.getMinutes() + ":" + date.getSeconds() + ":" + date.getMilliseconds();
	}

	var noteOnListener = function (e) 
	{		

		if (timeOffset == 0){
			timeOffset = (new Date()).getTime() - e.timestamp;
		}

		var now = (new Date()).getTime();

		if (!e.timestamp) 
			e.timestamp = now;


		var pianoNote = makePianoNote(e);

		joinPianoNote(pianoNote);
		// findPatterns(pianoNote);

		noteList.push(pianoNote);

		var oldNote = pendingNotes[pianoNote.getKey()];	

		if (oldNote)
		{
			console.log("Duplicate note " + oldNote.getKey());			
			oldNote.endEvent(e.timestamp);
			delete pendingNotes[oldNote.getKey()];
		}

		pendingNotes[pianoNote.getKey()] = pianoNote;
	
		// console.log("down:  " + pianoNote.getKey() + " V=" + e.rawVelocity + " X=" + notePosition(e.note) + " T=" + printTimestamp(e.timestamp));	
		
		lastNoteTime = now;
		
	};

	var noteOffListener = function (e) 
	{
		var pianoEvent = pendingNotes[getKey(e)];
		var now = (new Date()).getTime();
		if (!e.timestamp)
			e.timestamp = now ;//- timeOffset;

		if (pianoEvent){

			noteList.push(pianoEvent);
			delete pendingNotes[getKey(e)];
			pianoEvent.endEvent(e.timestamp);

			// console.log("up:  " + getKey(e) + " V=" + e.rawVelocity + " dT=" + pianoEvent.duration + " T=" + printTimestamp(e.timestamp));		
		}
		else 
		{
			console.log("Unmatched note " + getKey(e));
		}

		lastNoteTime = (new Date()).getTime();
	};

	WebMidi.enable(function(err){

		if (WebMidi.inputs.length > 0){

		  	var input = WebMidi.inputs[0];
		  	init();
		  	input.addListener('noteon', "all", noteOnListener);
		  	input.addListener('noteoff', "all", noteOffListener);
	  	} else
	  	{
	  		console.log("Enabling key mode");
	  		enableKeyMode();
	  		init();
	  	}
	});

	function getKeyNoteName(keycode){
		switch (keycode){
			case 0x41:
				return 'C';
			case 0x53:
				return 'D';
			case 0x44:
				return 'E';
			case 0x46:
				return 'F';
			case 0x47:
				return 'G';
			case 0x48:
				return 'A';
			case 0x4A:
				return 'B';
			default:
				return null;
			}
	}

	function noteFromKeyPress(e){

		var now = (new Date()).getTime();
		var noteName = getKeyNoteName(e.keyCode);
		var event = null;
		if (noteName)
		{
			event = {
				rawVelocity : 75,
				velocity : 0.7,
				timestamp : now, 
				note : { 
					name : noteName,
					octave: 0
				}
			};			
		}				
		return event;
	}

	function enableKeyMode(){

		var noteKeyDown = function keyDownTextField(e) {
			if (keyMap[e.keyCode]) return;
			keyMap[e.keyCode] = true;
			var midiEvent = noteFromKeyPress(e);
			if (midiEvent)
				noteOnListener(midiEvent);			  
		};
		
		var noteKeyUp = function keyDownTextField(e) {
			keyMap[e.keyCode] = false;
			var midiEvent = noteFromKeyPress(e);
			if (midiEvent)
				noteOffListener(midiEvent);			  
		};

		document.addEventListener("keydown", noteKeyDown, false);
		document.addEventListener("keyup", noteKeyUp, false);

	};



	function getDrawPos(now,drawTime)
	{
		var time = drawTime;
		if (drawTime < 1000000)
			time = drawTime + timeOffset;

		var yPos = 0;
		for (var i = timeline.length-1;i >= 0;i--){

			var timeBlock = timeline[i];
			var endTime = timeBlock.end;
			if (i == timeline.length -1)
			{
				if (timeBlock.end)
					console.log("Ended active time block");
				endTime = now;
			} else if (!timeBlock.end){
				console.log("Block " + i + " has no end");
			}
		
			if (timeBlock.start <= time && endTime >= time)
			{
				yPos += timeBlock.pixelsPerSecond * (endTime - time); 
				break;
			} else if (timeBlock.start > time) {
				yPos += timeBlock.pixelsPerSecond * (endTime - timeBlock.start);
			}	
			else
				console.log("No time block found for timestamp " + time);
		}

		return yPos;
	}	

	

	function onFrame(event){
	
		var now = (new Date()).getTime();
		if (timeState == "running") {
			//console.log(pendingNotes.length)
			if (Object.keys(pendingNotes).length == 0 && now > (SilenceDelay+lastNoteTime)) {
				if (timeline.length > 0){
					var lastBlock = timeline[timeline.length-1];
					lastBlock.end = now;
				}
				timeline.push({start:now,pixelsPerSecond:0});
				timeState = "paused";
				// console.log("Paused at " + now);
			}
		} else if (timeState == "paused") {
			if (Object.keys(pendingNotes).length > 0 || now < (SilenceDelay+lastNoteTime)) {
				timeline[timeline.length-1].end = lastNoteTime;
				timeline.push({start:lastNoteTime,pixelsPerSecond:PlayingPixelsPerSecond});
				timeState = "running";
				// console.log("Resumed at " + lastNoteTime);
			}
		}
		//else 
			//console.log("Unexpected state " + timeState);

		
   		for (var i = 0;i < noteList.length; i++)
   		{
   			midiEvent = noteList[i];
   			midiEvent.draw(now);

   			if (midiEvent.canDelete){
   				midiEvent.delete();
				noteList.splice(i,1);
				i--;
   			}
   		}

   		for (var patternKey in patternMatches){
			var patternMatch = patternMatches[patternKey];
			patternMatch.draw();
			if (patternMatch.canDelete){
				patternMatch.delete();
				delete patternMatches[patternKey];
			}
		}   		
	}

</script>
<body>
	<canvas id="myCanvas"  resize="true"  width="2000" height="1200"></canvas>
</body>

</html>
